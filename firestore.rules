/**
 * Core Philosophy: This ruleset implements a hybrid security model. Data is
 * segregated into two main categories: user-private data (Habits) and
 * collaborative data (Projects). User-private data follows a strict ownership
 * model, where users can only access their own information. The Projects
 * collection is intended for collaboration, but requires a denormalized
 * ownership field (e.g., 'ownerId') on each project document to enforce write
 * permissions. A global 'admin' role exists for administrative override.
 *
 * Data Structure:
 * - /users/{userId}/...: Contains all data private to a specific user, such as
 *   their habits and logs. Access is strictly controlled by the userId in the path.
 * - /projects/{projectId}/...: Contains project data, which is publicly readable.
 *   Write access is intended to be restricted to project owners/members.
 * - /roles_admin/{userId}: A special collection where the existence of a
 *   document signifies that the user has global admin privileges.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is granted explicitly.
 * - No User Listing: It is not possible to list all users in the system.
 * - Admin Override: Users with a document in /roles_admin can read and write
 *   all data in the database, providing essential administrative capabilities.
 * - Denormalization for Authorization: Write access to the /projects collection
 *   and its subcollections is critically dependent on an 'ownerId' field being
 *   present on the /projects/{projectId} document. Without this field, writes
 *   are disabled to maintain security.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Is the user authenticated?
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Does the requesting user's UID match the path's userId?
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Does a document already exist? Used for safe updates and deletes.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Is the requesting user the owner of an existing document?
     * Combines ownership and existence checks for state-changing operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Does the requesting user have a document in the roles_admin collection?
     * This grants global read/write privileges.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------
    match /projects/{projectId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update, delete: if isOwner(resource.data.ownerId) || isAdmin();
    }
    
    match /tasks/{taskId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update, delete: if isOwner(get(/databases/$(database)/documents/tasks/$(taskId)).data.ownerId) || isAdmin();
    }
    
    match /time_entries/{timeEntryId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update, delete: if isOwner(get(/databases/$(database)/documents/time_entries/$(timeEntryId)).data.ownerId) || isAdmin();
    }

    /**
     * @description Secures a user's private Habit documents.
     * @path /users/{userId}/habits/{habitId}
     * @allow (create) An authenticated user `abc` creates a habit in their own path `/users/abc/habits/123`.
     * @deny (get) A user `xyz` attempts to read a habit from `/users/abc/habits/123`.
     * @principle Restricts access to a user's own data tree (Ownership).
     */
    match /users/{userId}/habits/{habitId} {
      allow get, list, create, update, delete: if isOwner(userId) || isAdmin();
    }
    
    match /users/{userId}/habit_logs/{habitLogId} {
        allow get, list, create, update, delete: if isOwner(userId) || isAdmin();
    }
    
    match /users/{userId} {
      allow get, create, update, delete: if isOwner(userId) || isAdmin();
    }


    /**
     * @description Manages admin role documents. Existence of a document grants
     * a user admin privileges across the entire database.
     * @path /roles_admin/{userId}
     * @allow (get) An admin user `xyz` reads another user's role doc at `/roles_admin/abc`.
     * @deny (list) Any non-admin user attempts to list all admin documents.
     * @principle Role-Based Access Control (RBAC) and prevention of user enumeration.
     */
    match /roles_admin/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if false;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }
}
